Ø¨Ø§Ù„ØªØ£ÙƒÙŠØ¯ØŒ Ø³Ø£Ù‚Ø¯Ù… Ù„Ùƒ Ø¬Ù…ÙŠØ¹ Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ ÙƒØ§Ù…Ù„Ø© Ù…Ù† Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ø¥Ù„Ù‰ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©. Ø³Ø£ÙƒØªØ¨ ÙƒÙ„ Ù…Ù„Ù Ø¨Ø§Ø³Ù…Ù‡ ÙˆÙ…Ø³Ø§Ø±Ù‡ØŒ Ù…ØªØ¨ÙˆØ¹Ø§Ù‹ Ø¨Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ÙƒØ§Ù…Ù„ Ù„Ù‡. Ù‡ÙŠØ§ Ø¨Ù†Ø§:

Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ (Tree)

```
Muharram/
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ config.py
â”œâ”€â”€ main.py
â”œâ”€â”€ update.sh
â”œâ”€â”€ database/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ db_handler.py
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ auth_service.py
â”‚   â”œâ”€â”€ publish_service.py
â”‚   â”œâ”€â”€ join_service.py
â”‚   â”œâ”€â”€ fetch_service.py
â”‚   â””â”€â”€ proxy_manager.py
â”œâ”€â”€ handlers/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ user_handlers.py
â”‚   â”œâ”€â”€ admin_handlers.py
â”‚   â””â”€â”€ callback_handlers.py
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ logger.py
â”‚   â”œâ”€â”€ helpers.py
â”‚   â””â”€â”€ encryption_tools.py
â”œâ”€â”€ logs/
â”‚   â””â”€â”€ (Ù…Ù„ÙØ§Øª Ø§Ù„Ø³Ø¬Ù„ Ù‡Ù†Ø§)
â”œâ”€â”€ temp/
â”‚   â””â”€â”€ (Ù…Ù„ÙØ§Øª Ù…Ø¤Ù‚ØªØ© Ù‡Ù†Ø§)
â””â”€â”€ backups/
    â””â”€â”€ (Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª)
```

---

1. Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¬Ø°Ø±ÙŠØ© (Root)

1.1 .gitignore

```gitignore
# Python
__pycache__/
*.py[cod]
*.pyo
*.pyd
*.db
*.db-journal
venv/
env/
.env

# Logs
logs/*.log
*.log

# Temp
temp/*

# Backups
backups/*

# IDE
.vscode/
.idea/

# System
.DS_Store
*.swp
*.swo
*~
```

1.2 README.md

```markdown
# Ø¨ÙˆØª Ù…Ø­Ø±Ù… (Muharram Bot)

Ø¨ÙˆØª ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… Ù…ØªÙƒØ§Ù…Ù„ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø­Ø³Ø§Ø¨Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø©ØŒ Ù†Ø´Ø± ØªÙ„Ù‚Ø§Ø¦ÙŠØŒ Ø§Ù†Ø¶Ù…Ø§Ù… Ø¢Ù„ÙŠØŒ Ø¬Ù„Ø¨ Ø±ÙˆØ§Ø¨Ø·ØŒ Ù…Ø¹ Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ù…ØªØ·ÙˆØ±Ø©.

## Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª
- Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø±Ù‚Ø§Ù… (Ø¥Ø¶Ø§ÙØ©ØŒ Ø¹Ø±Ø¶ØŒ ÙØ­ØµØŒ Ø­Ø°Ù) Ù…Ø¹ ØªØ´ÙÙŠØ± Ø§Ù„Ø¬Ù„Ø³Ø§Øª
- Ù…Ø­Ø±Ùƒ Ù†Ø´Ø± Ø°ÙƒÙŠ Ù…Ø¹ Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø¤Ù‚Øª ÙˆØ§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù
- Ù…Ø­Ø±Ùƒ Ø§Ù†Ø¶Ù…Ø§Ù… Ø¢Ù„ÙŠ Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø§Ù„Ø°ÙƒÙŠ
- Ø¬Ù„Ø¨ Ø±ÙˆØ§Ø¨Ø· ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… ÙˆÙˆØ§ØªØ³Ø§Ø¨ Ù…Ù† Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª
- Ù†Ø¸Ø§Ù… Ø§Ø´ØªØ±Ø§ÙƒØ§Øª Ø¨Ø£ÙƒÙˆØ§Ø¯ ØªÙØ¹ÙŠÙ„
- Ù„ÙˆØ­Ø© Ø£Ø¯Ù…Ù† Ù…ØªÙƒØ§Ù…Ù„Ø© Ù…Ø¹ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
- Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„Ù‚Ø§Ø¦Ø¯ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£ÙƒÙˆØ§Ø¯
- Ø¯Ø¹Ù… Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠ (SOCKS5)
- Ù†Ø¸Ø§Ù… Ù…Ø±Ø§ÙŠØ§ (Mirror Token) Ù„Ù„Ø·ÙˆØ§Ø±Ø¦
- Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ù‚Ù†Ø§Ø© Ø®Ø§ØµØ©
- ØªØ­Ø¯ÙŠØ« Ø³Ù‡Ù„ Ø¹Ø¨Ø± Git

## Ø§Ù„ØªØ«Ø¨ÙŠØª ÙˆØ§Ù„ØªØ´ØºÙŠÙ„

### 1. Ø§Ø³ØªÙ†Ø³Ø§Ø® Ø§Ù„Ù…Ø´Ø±ÙˆØ¹
```bash
git clone https://github.com/yourusername/Muharram.git
cd Muharram
```

2. Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙŠØ¦Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©

```bash
python3 -m venv venv
source venv/bin/activate
```

3. ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª

```bash
pip install -r requirements.txt
```

4. Ø¥Ø¹Ø¯Ø§Ø¯ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª

(Ø³ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù†Ø¯ Ø§Ù„ØªØ´ØºÙŠÙ„)

5. ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª

```bash
python3 main.py
```

Ø§Ù„ØªØ­Ø¯ÙŠØ«

```bash
git pull
source venv/bin/activate
pip install -r requirements.txt
systemctl restart muharram   # Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ³ØªØ®Ø¯Ù… systemd
```

Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©

Â· Ø§Ù†Ø³Ø® Ù…Ù„Ù config.py Ø¥Ù„Ù‰ config_local.py Ù„Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©.
Â· Ø£Ø¶Ù Ù‚Ù†Ø§Ø© Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ ÙÙŠ Ù„ÙˆØ­Ø© Ø§Ù„Ø£Ø¯Ù…Ù†.

Ø§Ù„ØªØ±Ø®ÙŠØµ

Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ‚ Ù…Ø­ÙÙˆØ¸Ø©.

```

### 1.3 `requirements.txt`
```txt
python-telegram-bot[job-queue]==20.3
telethon==1.34.0
cryptography==41.0.7
psutil==5.9.6
aiofiles==23.2.1
```

1.4 config.py

```python
# -*- coding: utf-8 -*-
import os

# ================== Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ==================
BOT_TOKEN = "8207472950:AAHS9FqJzNARdhSj1iBu_y1WxzFOSe7VOZs"
MIRROR_BOT_TOKEN = ""  # ØªÙˆÙƒÙ† Ø§Ø­ØªÙŠØ§Ø·ÙŠ
API_ID = 30301641
API_HASH = "9a4144e4215946eb14540c659f173852"
ADMIN_IDS = [6056642165]

# ================== Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ==================
DATABASE_NAME = "data.db"
ENCRYPTION_KEY = "mysecretkeymustbe32byteslong!"  # 32 Ø­Ø±ÙØ§Ù‹

# ================== Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ==================
MAX_NUMBERS_PER_USER = 5
MAX_ADS_PER_USER = 20

# ================== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø³ÙŠØ±ÙØ± ==================
MAX_LOG_SIZE_MB = 10
MAX_TEMP_SIZE_MB = 50
LOG_FILE = "logs/bot.log"
ERROR_LOG_FILE = "logs/error.log"
PAUSE_FILE = "last_shutdown.txt"

# ================== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù…ØªØºÙŠØ±Ø© (ØªØ¹Ø¯Ù„ Ù…Ù† Ù„ÙˆØ­Ø© Ø§Ù„Ø£Ø¯Ù…Ù†) ==================
SETTINGS = {
    "subscription_price": "10$",
    "payment_number": "123456789",
    "whatsapp_link": "https://wa.me/123456789",
    "mirror_token": "",
    "backup_channel": "",  # Ù…Ø¹Ø±Ù Ù‚Ù†Ø§Ø© Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ
}
```

1.5 main.py

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys
import os
import asyncio
import time
import logging
import subprocess
from datetime import datetime
sys.path.append(os.path.dirname(__file__))

from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters
from telegram.warnings import PTBUserWarning
from telegram.error import Conflict, Unauthorized
import warnings

warnings.filterwarnings("ignore", category=PTBUserWarning, message=".*CallbackQueryHandler.*")

from config import BOT_TOKEN, API_ID, API_HASH, ADMIN_IDS, DATABASE_NAME, ENCRYPTION_KEY, MAX_LOG_SIZE_MB, SETTINGS
from database.db_handler import Database
from utils.logger import setup_logger
from services.auth_service import AuthService
from services.publish_service import PublishService
from services.join_service import JoinService
from services.fetch_service import FetchService
from services.proxy_manager import ProxyManager
from handlers.user_handlers import UserHandlers
from handlers.admin_handlers import AdminHandlers
from handlers.callback_handlers import CallbackHandlers

logger = setup_logger("Muharram", "logs/bot.log", max_bytes=MAX_LOG_SIZE_MB * 1024 * 1024)

# ================== ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù„Ø®Ø¯Ù…Ø§Øª ==================
db = Database(DATABASE_NAME, ENCRYPTION_KEY)
auth_service = AuthService(db, API_ID, API_HASH)
publish_service = PublishService(db, API_ID, API_HASH)
join_service = JoinService(db, API_ID, API_HASH)
fetch_service = FetchService(db, API_ID, API_HASH)
proxy_manager = ProxyManager(db)

user_handlers = UserHandlers(db, auth_service, publish_service, join_service, fetch_service, ADMIN_IDS)
admin_handlers = AdminHandlers(db, ADMIN_IDS, publish_service, join_service, proxy_manager, bot=None)
callback_handlers = CallbackHandlers(user_handlers, admin_handlers)

# ================== Ø¨Ù†Ø§Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ==================
application = Application.builder().token(BOT_TOKEN).build()
admin_handlers.bot = application.bot

# ================== Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø§Øª ==================
application.add_handler(CommandHandler("start", user_handlers.start))
application.add_handler(CallbackQueryHandler(callback_handlers.handle))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, user_handlers.handle_message))

# ================== Ù…Ù‡Ù…Ø© ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© ==================
async def cleanup_job():
    while True:
        await asyncio.sleep(3600)  # ÙƒÙ„ Ø³Ø§Ø¹Ø©
        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù…Ø¤Ù‚Øª
        temp_dir = "temp"
        if os.path.exists(temp_dir):
            now = time.time()
            for f in os.listdir(temp_dir):
                f_path = os.path.join(temp_dir, f)
                if os.path.isfile(f_path):
                    if now - os.path.getmtime(f_path) > 3600:
                        os.remove(f_path)
                        logger.info(f"ØªÙ… Ø­Ø°Ù Ù…Ù„Ù Ù…Ø¤Ù‚Øª: {f}")
        # ØªÙ†Ø¸ÙŠÙ Ù…Ù„ÙØ§Øª Ø§Ù„Ù„ÙˆØ¬ Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (ÙŠØªÙ… Ø¨ÙˆØ§Ø³Ø·Ø© RotatingFileHandler)
        # Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await backup_database()

# ================== Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ==================
async def backup_database():
    channel_id = db.fetch_one("SELECT value FROM global_settings WHERE key='backup_channel'")
    if channel_id and channel_id['value']:
        try:
            backup_dir = "backups"
            os.makedirs(backup_dir, exist_ok=True)
            backup_name = f"{backup_dir}/data_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db"
            import shutil
            shutil.copy2(DATABASE_NAME, backup_name)
            with open(backup_name, 'rb') as f:
                await application.bot.send_document(
                    chat_id=int(channel_id['value']),
                    document=f,
                    caption=f"ğŸ“¦ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
                )
            # Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø¢Ø®Ø± 5 Ù†Ø³Ø® ÙÙ‚Ø·
            backups = sorted(os.listdir(backup_dir))
            for old_backup in backups[:-5]:
                os.remove(os.path.join(backup_dir, old_backup))
            logger.info("ØªÙ… Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø¨Ù†Ø¬Ø§Ø­")
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ: {e}")

# ================== Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ø®Ù„ÙÙŠØ© ==================
loop = asyncio.get_event_loop()
loop.create_task(cleanup_job())

# ================== ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø¹Ø·Ø§Ù„ ==================
def main():
    try:
        logger.info("Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª...")
        application.run_polling()
    except (Conflict, Unauthorized) as e:
        logger.critical(f"Ø§Ù„Ø¨ÙˆØª Ù…Ø­Ø¸ÙˆØ± Ø£Ùˆ Ù…ØªØ¹Ø§Ø±Ø¶: {e}. Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„ØªÙˆÙƒÙ† Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ...")
        if SETTINGS.get('mirror_token'):
            # Ø­ÙØ¸ Ø§Ù„ØªÙˆÙƒÙ† Ø§Ù„Ø­Ø§Ù„ÙŠ
            with open("last_token.txt", "w") as f:
                f.write(BOT_TOKEN)
            # Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ Ø¨Ø§Ù„ØªÙˆÙƒÙ† Ø§Ù„Ø¬Ø¯ÙŠØ¯
            os.environ['BOT_TOKEN'] = SETTINGS['mirror_token']
            os.execv(sys.executable, ['python'] + sys.argv)
        else:
            logger.critical("Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªÙˆÙƒÙ† Ø§Ø­ØªÙŠØ§Ø·ÙŠ. Ø§Ù„Ø¨ÙˆØª Ù…ØªÙˆÙ‚Ù.")
    except Exception as e:
        logger.exception(f"Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹: {e}")

if __name__ == "__main__":
    main()
```

1.6 update.sh

```bash
#!/bin/bash
# Ø³ÙƒØ±Ø¨Øª ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙˆØª

cd /root/Muharram || exit 1

# Ø³Ø­Ø¨ Ø¢Ø®Ø± Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª
git pull origin main

# ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
source venv/bin/activate

# ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª
pip install -r requirements.txt

# Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ø®Ø¯Ù…Ø© (Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…Ø³Ø¬Ù„Ø© ÙÙŠ systemd)
if systemctl is-active --quiet muharram; then
    systemctl restart muharram
else
    echo "Ø§Ù„Ø®Ø¯Ù…Ø© ØºÙŠØ± Ù…Ø³Ø¬Ù„Ø© ÙÙŠ systemd. Ø£Ø¹Ø¯ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙŠØ¯ÙˆÙŠØ§Ù‹."
fi

echo "âœ… ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ù†Ø¬Ø§Ø­"
```

---

2. Ù…Ø¬Ù„Ø¯ database

2.1 database/__init__.py

```python
# Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù ÙŠØ¬Ø¹Ù„ Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø­Ø²Ù…Ø© Ø¨Ø§ÙŠØ«ÙˆÙ†
```

2.2 database/db_handler.py

```python
# -*- coding: utf-8 -*-
import sqlite3
import logging
from datetime import datetime, timedelta
from utils.encryption_tools import AESCipher

logger = logging.getLogger(__name__)

class Database:
    def __init__(self, db_path, encryption_key):
        self.db_path = db_path
        self.cipher = AESCipher(encryption_key)
        self._init_db()

    def _init_db(self):
        with self._get_conn() as conn:
            # Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
            conn.execute("""
CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY,
    username TEXT,
    first_name TEXT,
    subscription_end DATE,
    referral_code TEXT UNIQUE,
    referred_by INTEGER,
    bonus_days INTEGER DEFAULT 0,
    pause_days INTEGER DEFAULT 0,
    total_posts INTEGER DEFAULT 0,
    total_joins INTEGER DEFAULT 0,
    total_fetches INTEGER DEFAULT 0,
    full_name TEXT,
    status TEXT DEFAULT 'active',
    health_score INTEGER DEFAULT 100,
    safety_mode BOOLEAN DEFAULT 0,
    last_flood_time TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
""")
            # Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…
            conn.execute("""
CREATE TABLE IF NOT EXISTS numbers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    phone TEXT,
    session_string TEXT,
    proxy TEXT,
    is_active BOOLEAN DEFAULT 1,
    session_type TEXT DEFAULT 'user',  -- 'user' or 'bot'
    is_premium BOOLEAN DEFAULT 0,
    twofa TEXT,
    last_used TIMESTAMP,
    status TEXT DEFAULT 'active',
    health_score INTEGER DEFAULT 100,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(user_id) REFERENCES users(user_id)
)
""")
            # Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†Ø§Øª
            conn.execute("""
CREATE TABLE IF NOT EXISTS ads (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    ad_text TEXT,
    ad_type TEXT DEFAULT 'public',  # 'public', 'special'
    target_groups TEXT,  -- Ù‚Ø§Ø¦Ù…Ø© ids Ù…ÙØµÙˆÙ„Ø© Ø¨ÙÙˆØ§ØµÙ„
    delay_min INTEGER DEFAULT 30,
    delay_max INTEGER DEFAULT 60,
    is_active BOOLEAN DEFAULT 1,
    total_sent INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(user_id) REFERENCES users(user_id)
)
""")
            # Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
            conn.execute("""
CREATE TABLE IF NOT EXISTS groups (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    group_id TEXT,
    group_name TEXT,
    group_type TEXT DEFAULT 'source',  -- 'source', 'target'
    is_active BOOLEAN DEFAULT 1,
    join_status TEXT DEFAULT 'pending',  -- 'pending', 'joined', 'failed'
    joined_at TIMESTAMP,
    added_by INTEGER,
    FOREIGN KEY(user_id) REFERENCES users(user_id)
)
""")
            # Ø¬Ø¯ÙˆÙ„ Ø¬Ù„Ø¨ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
            conn.execute("""
CREATE TABLE IF NOT EXISTS fetched_links (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    source_group_id TEXT,
    link TEXT,
    link_type TEXT,  -- 'telegram', 'whatsapp'
    fetched_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(user_id) REFERENCES users(user_id)
)
""")
            # Ø¬Ø¯ÙˆÙ„ Ø£ÙƒÙˆØ§Ø¯ Ø§Ù„ØªÙØ¹ÙŠÙ„
            conn.execute("""
CREATE TABLE IF NOT EXISTS activation_codes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    code TEXT UNIQUE,
    days INTEGER,
    is_used BOOLEAN DEFAULT 0,
    used_by INTEGER,
    used_at TIMESTAMP,
    created_by INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(used_by) REFERENCES users(user_id)
)
""")
            # Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
            conn.execute("""
CREATE TABLE IF NOT EXISTS global_settings (
    key TEXT PRIMARY KEY,
    value TEXT
)
""")
            # Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠØ§Øª
            conn.execute("""
CREATE TABLE IF NOT EXISTS proxies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    proxy_type TEXT DEFAULT 'socks5',
    proxy_address TEXT,
    proxy_port INTEGER,
    proxy_username TEXT,
    proxy_password TEXT,
    is_active BOOLEAN DEFAULT 1,
    usage_count INTEGER DEFAULT 0,
    last_used TIMESTAMP,
    health_score INTEGER DEFAULT 100,
    UNIQUE(proxy_address, proxy_port)
)
""")
            # Ø¬Ø¯ÙˆÙ„ Ø³Ø¬Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
            conn.execute("""
CREATE TABLE IF NOT EXISTS error_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    number_id INTEGER,
    error_type TEXT,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
""")
            # Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
            conn.execute("""
CREATE TABLE IF NOT EXISTS daily_stats (
    date TEXT PRIMARY KEY,
    total_users INTEGER DEFAULT 0,
    total_posts INTEGER DEFAULT 0,
    total_joins INTEGER DEFAULT 0,
    total_fetches INTEGER DEFAULT 0,
    total_errors INTEGER DEFAULT 0
)
""")
            # Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø¥Ø°Ø§ Ù„Ù… ØªÙˆØ¬Ø¯
            default_settings = [
                ('subscription_price', '10$'),
                ('payment_number', '123456789'),
                ('whatsapp_link', 'https://wa.me/123456789'),
                ('mirror_token', ''),
                ('backup_channel', ''),
                ('leader_username', 'leader')
            ]
            for key, value in default_settings:
                conn.execute("INSERT OR IGNORE INTO global_settings (key, value) VALUES (?, ?)", (key, value))

    def _get_conn(self):
        """Ø¥Ù†Ø´Ø§Ø¡ Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        return conn

    # ========== Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ==========
    def add_user(self, user_id, username, first_name, referred_by=None):
        with self._get_conn() as conn:
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            existing = conn.execute("SELECT user_id FROM users WHERE user_id=?", (user_id,)).fetchone()
            if existing:
                return False
            # Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø¥Ø­Ø§Ù„Ø© ÙØ±ÙŠØ¯
            import random, string
            referral_code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
            conn.execute("""
                INSERT INTO users (user_id, username, first_name, referral_code, referred_by)
                VALUES (?, ?, ?, ?, ?)
            """, (user_id, username, first_name, referral_code, referred_by))
            return True

    def get_user(self, user_id):
        with self._get_conn() as conn:
            return conn.execute("SELECT * FROM users WHERE user_id=?", (user_id,)).fetchone()

    def update_user_subscription(self, user_id, days):
        with self._get_conn() as conn:
            expiry = (datetime.now() + timedelta(days=days)).date()
            conn.execute("UPDATE users SET subscription_end=? WHERE user_id=?", (expiry, user_id))

    def update_user_pause(self, user_id, days):
        with self._get_conn() as conn:
            conn.execute("UPDATE users SET pause_days=pause_days+? WHERE user_id=?", (days, user_id))

    # ========== Ø¯ÙˆØ§Ù„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ==========
    def add_number(self, user_id, phone, session_string, proxy=None, twofa=None, session_type='user'):
        with self._get_conn() as conn:
            cursor = conn.execute("""
                INSERT INTO numbers (user_id, phone, session_string, proxy, twofa, session_type)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (user_id, phone, self.cipher.encrypt(session_string), proxy, twofa, session_type))
            return cursor.lastrowid

    def get_user_numbers(self, user_id):
        with self._get_conn() as conn:
            rows = conn.execute("SELECT * FROM numbers WHERE user_id=?", (user_id,)).fetchall()
            for row in rows:
                row['session_string'] = self.cipher.decrypt(row['session_string']) if row['session_string'] else None
            return rows

    def get_number(self, number_id):
        with self._get_conn() as conn:
            row = conn.execute("SELECT * FROM numbers WHERE id=?", (number_id,)).fetchone()
            if row:
                row['session_string'] = self.cipher.decrypt(row['session_string']) if row['session_string'] else None
            return row

    def delete_number(self, number_id):
        with self._get_conn() as conn:
            conn.execute("DELETE FROM numbers WHERE id=?", (number_id,))

    def update_number_health(self, number_id, health_score):
        with self._get_conn() as conn:
            conn.execute("UPDATE numbers SET health_score=? WHERE id=?", (health_score, number_id))

    def get_all_numbers(self):
        with self._get_conn() as conn:
            rows = conn.execute("SELECT * FROM numbers WHERE is_active=1").fetchall()
            for row in rows:
                row['session_string'] = self.cipher.decrypt(row['session_string']) if row['session_string'] else None
            return rows

    # ========== Ø¯ÙˆØ§Ù„ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†Ø§Øª ==========
    def add_ad(self, user_id, ad_text, ad_type='public', target_groups=None, delay_min=30, delay_max=60):
        with self._get_conn() as conn:
            cursor = conn.execute("""
                INSERT INTO ads (user_id, ad_text, ad_type, target_groups, delay_min, delay_max)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (user_id, ad_text, ad_type, target_groups, delay_min, delay_max))
            return cursor.lastrowid

    def get_user_ads(self, user_id):
        with self._get_conn() as conn:
            return conn.execute("SELECT * FROM ads WHERE user_id=?", (user_id,)).fetchall()

    def get_ad(self, ad_id):
        with self._get_conn() as conn:
            return conn.execute("SELECT * FROM ads WHERE id=?", (ad_id,)).fetchone()

    def update_ad_status(self, ad_id, is_active):
        with self._get_conn() as conn:
            conn.execute("UPDATE ads SET is_active=? WHERE id=?", (is_active, ad_id))

    def increment_ad_sent(self, ad_id):
        with self._get_conn() as conn:
            conn.execute("UPDATE ads SET total_sent=total_sent+1 WHERE id=?", (ad_id,))

    # ========== Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ==========
    def add_group(self, user_id, group_id, group_name, group_type='source', added_by=None):
        with self._get_conn() as conn:
            cursor = conn.execute("""
                INSERT INTO groups (user_id, group_id, group_name, group_type, added_by)
                VALUES (?, ?, ?, ?, ?)
                ON CONFLICT(user_id, group_id) DO UPDATE SET group_name=excluded.group_name
            """, (user_id, group_id, group_name, group_type, added_by))
            return cursor.lastrowid

    def get_user_groups(self, user_id, group_type=None):
        with self._get_conn() as conn:
            if group_type:
                return conn.execute("SELECT * FROM groups WHERE user_id=? AND group_type=?", (user_id, group_type)).fetchall()
            return conn.execute("SELECT * FROM groups WHERE user_id=?", (user_id,)).fetchall()

    def get_group(self, group_id):
        with self._get_conn() as conn:
            return conn.execute("SELECT * FROM groups WHERE group_id=?", (group_id,)).fetchone()

    def update_group_join_status(self, group_id, status, joined_at=None):
        with self._get_conn() as conn:
            conn.execute("UPDATE groups SET join_status=?, joined_at=? WHERE group_id=?", (status, joined_at, group_id))

    def delete_group(self, group_id):
        with self._get_conn() as conn:
            conn.execute("DELETE FROM groups WHERE group_id=?", (group_id,))

    # ========== Ø¯ÙˆØ§Ù„ Ø¬Ù„Ø¨ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· ==========
    def add_fetched_link(self, user_id, source_group_id, link, link_type):
        with self._get_conn() as conn:
            conn.execute("""
                INSERT INTO fetched_links (user_id, source_group_id, link, link_type)
                VALUES (?, ?, ?, ?)
            """, (user_id, source_group_id, link, link_type))

    def get_user_fetched_links(self, user_id, limit=50):
        with self._get_conn() as conn:
            return conn.execute("""
                SELECT * FROM fetched_links 
                WHERE user_id=? 
                ORDER BY fetched_at DESC 
                LIMIT ?
            """, (user_id, limit)).fetchall()

    # ========== Ø¯ÙˆØ§Ù„ Ø£ÙƒÙˆØ§Ø¯ Ø§Ù„ØªÙØ¹ÙŠÙ„ ==========
    def generate_codes(self, num_codes, days, created_by):
        import random, string
        codes = []
        with self._get_conn() as conn:
            for _ in range(num_codes):
                code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=12))
                conn.execute("INSERT INTO activation_codes (code, days, created_by) VALUES (?, ?, ?)", (code, days, created_by))
                codes.append(code)
        return codes

    def use_code(self, code, user_id):
        with self._get_conn() as conn:
            code_data = conn.execute("SELECT * FROM activation_codes WHERE code=? AND is_used=0", (code,)).fetchone()
            if code_data:
                conn.execute("""
                    UPDATE activation_codes SET is_used=1, used_by=?, used_at=CURRENT_TIMESTAMP
                    WHERE code=?
                """, (user_id, code))
                return code_data['days']
        return None

    def get_all_codes(self):
        with self._get_conn() as conn:
            return conn.execute("SELECT * FROM activation_codes ORDER BY created_at DESC").fetchall()

    def delete_code(self, code):
        with self._get_conn() as conn:
            conn.execute("DELETE FROM activation_codes WHERE code=?", (code,))

    # ========== Ø¯ÙˆØ§Ù„ Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠØ§Øª ==========
    def add_proxy(self, proxy_type, proxy_address, proxy_port, proxy_username=None, proxy_password=None):
        with self._get_conn() as conn:
            try:
                conn.execute("""
                    INSERT INTO proxies (proxy_type, proxy_address, proxy_port, proxy_username, proxy_password)
                    VALUES (?, ?, ?, ?, ?)
                """, (proxy_type, proxy_address, proxy_port, proxy_username, proxy_password))
                return True
            except sqlite3.IntegrityError:
                return False

    def get_proxies(self, active_only=True):
        with self._get_conn() as conn:
            if active_only:
                return conn.execute("SELECT * FROM proxies WHERE is_active=1").fetchall()
            return conn.execute("SELECT * FROM proxies").fetchall()

    def get_proxy(self, proxy_id):
        with self._get_conn() as conn:
            return conn.execute("SELECT * FROM proxies WHERE id=?", (proxy_id,)).fetchone()

    def update_proxy_status(self, proxy_id, is_active):
        with self._get_conn() as conn:
            conn.execute("UPDATE proxies SET is_active=? WHERE id=?", (is_active, proxy_id))

    def delete_proxy(self, proxy_id):
        with self._get_conn() as conn:
            conn.execute("DELETE FROM proxies WHERE id=?", (proxy_id,))

    def increment_proxy_usage(self, proxy_id):
        with self._get_conn() as conn:
            conn.execute("UPDATE proxies SET usage_count=usage_count+1, last_used=CURRENT_TIMESTAMP WHERE id=?", (proxy_id,))

    # ========== Ø¯ÙˆØ§Ù„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© ==========
    def get_setting(self, key):
        with self._get_conn() as conn:
            row = conn.execute("SELECT value FROM global_settings WHERE key=?", (key,)).fetchone()
            return row['value'] if row else None

    def set_setting(self, key, value):
        with self._get_conn() as conn:
            conn.execute("INSERT OR REPLACE INTO global_settings (key, value) VALUES (?, ?)", (key, value))

    # ========== Ø¯ÙˆØ§Ù„ ØªÙ†ÙÙŠØ° Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¹Ø§Ù…Ø© ==========
    def execute_query(self, query, params=()):
        with self._get_conn() as conn:
            return conn.execute(query, params).fetchall()

    def fetch_one(self, query, params=()):
        with self._get_conn() as conn:
            return conn.execute(query, params).fetchone()

    # ========== Ø¯ÙˆØ§Ù„ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ==========
    def update_daily_stats(self):
        today = datetime.now().date().isoformat()
        with self._get_conn() as conn:
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ÙŠÙˆÙ…
            stats = conn.execute("SELECT * FROM daily_stats WHERE date=?", (today,)).fetchone()
            if not stats:
                conn.execute("INSERT INTO daily_stats (date) VALUES (?)", (today,))
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯
            total_users = conn.execute("SELECT COUNT(*) FROM users").fetchone()[0]
            total_posts = conn.execute("SELECT SUM(total_sent) FROM ads").fetchone()[0] or 0
            total_joins = conn.execute("SELECT COUNT(*) FROM groups WHERE join_status='joined'").fetchone()[0]
            total_fetches = conn.execute("SELECT COUNT(*) FROM fetched_links").fetchone()[0]
            total_errors = conn.execute("SELECT COUNT(*) FROM error_logs WHERE date(created_at)=?", (today,)).fetchone()[0]
            conn.execute("""
                UPDATE daily_stats SET 
                    total_users=?, total_posts=?, total_joins=?, total_fetches=?, total_errors=?
                WHERE date=?
            """, (total_users, total_posts, total_joins, total_fetches, total_errors, today))

    def get_stats(self, days=7):
        with self._get_conn() as conn:
            return conn.execute("""
                SELECT * FROM daily_stats 
                WHERE date >= date('now', ?) 
                ORDER BY date DESC
            """, (f'-{days} days',)).fetchall()

    # ========== Ø¯ÙˆØ§Ù„ Ø³Ø¬Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ==========
    def log_error(self, user_id, error_type, error_message, number_id=None):
        with self._get_conn() as conn:
            conn.execute("""
                INSERT INTO error_logs (user_id, number_id, error_type, error_message)
                VALUES (?, ?, ?, ?)
            """, (user_id, number_id, error_type, error_message))
```

---

3. Ù…Ø¬Ù„Ø¯ services

3.1 services/__init__.py

```python
# Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù ÙŠØ¬Ø¹Ù„ Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø­Ø²Ù…Ø© Ø¨Ø§ÙŠØ«ÙˆÙ†
```

3.2 services/auth_service.py

```python
# -*- coding: utf-8 -*-
import logging
from telethon import TelegramClient
from telethon.errors import SessionPasswordNeededError, PhoneCodeInvalidError, FloodWaitError
import asyncio
from utils.encryption_tools import AESCipher
import random
import string

logger = logging.getLogger(__name__)

class AuthService:
    def __init__(self, db, api_id, api_hash):
        self.db = db
        self.api_id = api_id
        self.api_hash = api_hash
        self.active_clients = {}  # ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø§Ù„Ù†Ø´Ø·ÙŠÙ† Ù…Ø¤Ù‚ØªØ§Ù‹

    async def send_code(self, phone, proxy=None):
        """Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªÙØ¹ÙŠÙ„ Ù„Ø±Ù‚Ù… Ù‡Ø§ØªÙ"""
        client = TelegramClient(
            f'session_{phone}',
            self.api_id,
            self.api_hash,
            proxy=proxy
        )
        await client.connect()
        try:
            await client.send_code_request(phone)
            # ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¹Ù…ÙŠÙ„ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù„Ø§Ø­Ù‚Ø§Ù‹
            self.active_clients[phone] = client
            return True, "ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø¨Ù†Ø¬Ø§Ø­"
        except FloodWaitError as e:
            return False, f"Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± {e.seconds} Ø«Ø§Ù†ÙŠØ©"
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯: {e}")
            return False, str(e)

    async def verify_code(self, phone, code, twofa=None):
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙˆØ¯ Ø§Ù„ØªÙØ¹ÙŠÙ„"""
        client = self.active_clients.get(phone)
        if not client:
            return False, "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø·Ù„Ø¨ ÙƒÙˆØ¯ Ø£ÙˆÙ„Ø§Ù‹"
        try:
            await client.sign_in(phone, code)
            session_string = client.session.save()
            await client.disconnect()
            del self.active_clients[phone]
            return True, session_string
        except SessionPasswordNeededError:
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ø®Ø·ÙˆØªÙŠÙ†
            if twofa:
                try:
                    await client.sign_in(password=twofa)
                    session_string = client.session.save()
                    await client.disconnect()
                    del self.active_clients[phone]
                    return True, session_string
                except Exception as e:
                    return False, f"Ø®Ø·Ø£ ÙÙŠ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±: {e}"
            else:
                return False, "twofa_needed"
        except PhoneCodeInvalidError:
            return False, "Ø§Ù„ÙƒÙˆØ¯ ØºÙŠØ± ØµØ­ÙŠØ­"
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚: {e}")
            return False, str(e)

    async def verify_twofa(self, phone, twofa):
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø¨Ø®Ø·ÙˆØªÙŠÙ†"""
        client = self.active_clients.get(phone)
        if not client:
            return False, "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø·Ù„Ø¨ ÙƒÙˆØ¯ Ø£ÙˆÙ„Ø§Ù‹"
        try:
            await client.sign_in(password=twofa)
            session_string = client.session.save()
            await client.disconnect()
            del self.active_clients[phone]
            return True, session_string
        except Exception as e:
            return False, str(e)

    async def check_number_health(self, session_string):
        """ÙØ­Øµ ØµØ­Ø© Ø§Ù„Ø±Ù‚Ù…"""
        client = TelegramClient('temp_health', self.api_id, self.api_hash)
        try:
            client.session.load(session_string)
            await client.connect()
            if await client.is_user_authorized():
                me = await client.get_me()
                await client.disconnect()
                return True, me.phone
            return False, "ØºÙŠØ± Ù…ÙØ¹Ù„"
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ÙØ­Øµ Ø§Ù„ØµØ­Ø©: {e}")
            return False, str(e)
        finally:
            await client.disconnect()

    async def get_dialogs(self, session_string, limit=100):
        """Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ù„Ø±Ù‚Ù…"""
        client = TelegramClient('temp_dialogs', self.api_id, self.api_hash)
        try:
            client.session.load(session_string)
            await client.connect()
            dialogs = await client.get_dialogs(limit=limit)
            result = []
            for d in dialogs:
                result.append({
                    'id': d.id,
                    'name': d.name,
                    'type': 'group' if d.is_group else 'channel' if d.is_channel else 'user'
                })
            return True, result
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª: {e}")
            return False, str(e)
        finally:
            await client.disconnect()
```

3.3 services/publish_service.py

```python
# -*- coding: utf-8 -*-
import logging
import asyncio
import random
from telethon import TelegramClient
from telethon.errors import FloodWaitError, RPCError
from datetime import datetime

logger = logging.getLogger(__name__)

class PublishService:
    def __init__(self, db, api_id, api_hash):
        self.db = db
        self.api_id = api_id
        self.api_hash = api_hash
        self.running_tasks = {}  # ad_id -> task
        self.paused = False

    async def publish_ad(self, ad_id, number_id, target_group_id):
        """Ù†Ø´Ø± Ø¥Ø¹Ù„Ø§Ù† ÙˆØ§Ø­Ø¯"""
        ad = self.db.get_ad(ad_id)
        number = self.db.get_number(number_id)
        if not ad or not number:
            return False, "Ø§Ù„Ø¥Ø¹Ù„Ø§Ù† Ø£Ùˆ Ø§Ù„Ø±Ù‚Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯"

        client = TelegramClient('temp_publish', self.api_id, self.api_hash)
        try:
            client.session.load(number['session_string'])
            await client.connect()
            entity = await client.get_entity(int(target_group_id))
            await client.send_message(entity, ad['ad_text'])
            self.db.increment_ad_sent(ad_id)
            logger.info(f"ØªÙ… Ù†Ø´Ø± Ø§Ù„Ø¥Ø¹Ù„Ø§Ù† {ad_id} ÙÙŠ {target_group_id}")
            return True, "ØªÙ… Ø§Ù„Ù†Ø´Ø± Ø¨Ù†Ø¬Ø§Ø­"
        except FloodWaitError as e:
            logger.warning(f"Flood wait {e.seconds} Ø«Ø§Ù†ÙŠØ©")
            return False, f"Ø§Ù†ØªØ¸Ø± {e.seconds} Ø«Ø§Ù†ÙŠØ©"
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø´Ø±: {e}")
            return False, str(e)
        finally:
            await client.disconnect()

    async def start_auto_publish(self, ad_id, numbers, target_groups):
        """Ø¨Ø¯Ø¡ Ø§Ù„Ù†Ø´Ø± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ø¥Ø¹Ù„Ø§Ù†"""
        if ad_id in self.running_tasks:
            return False, "Ø§Ù„Ù†Ø´Ø± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…ÙØ¹Ù„ Ø¨Ø§Ù„ÙØ¹Ù„"

        async def publish_loop():
            while not self.paused:
                ad = self.db.get_ad(ad_id)
                if not ad or not ad['is_active']:
                    break
                # Ø§Ø®ØªÙŠØ§Ø± Ø±Ù‚Ù… Ø¹Ø´ÙˆØ§Ø¦ÙŠ
                number = random.choice(numbers)
                # Ø§Ø®ØªÙŠØ§Ø± Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
                target = random.choice(target_groups.split(','))
                success, msg = await self.publish_ad(ad_id, number['id'], target.strip())
                if not success:
                    logger.error(f"ÙØ´Ù„ Ø§Ù„Ù†Ø´Ø±: {msg}")
                # ØªØ£Ø®ÙŠØ± Ø¹Ø´ÙˆØ§Ø¦ÙŠ
                delay = random.randint(ad['delay_min'], ad['delay_max'])
                await asyncio.sleep(delay)
            # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ù‡Ù…Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡
            if ad_id in self.running_tasks:
                del self.running_tasks[ad_id]

        task = asyncio.create_task(publish_loop())
        self.running_tasks[ad_id] = task
        return True, "Ø¨Ø¯Ø£ Ø§Ù„Ù†Ø´Ø± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ"

    def stop_auto_publish(self, ad_id):
        """Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù†Ø´Ø± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ"""
        if ad_id in self.running_tasks:
            self.running_tasks[ad_id].cancel()
            del self.running_tasks[ad_id]
            return True, "ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù†Ø´Ø± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ"
        return False, "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù†Ø´Ø± ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†"

    def pause_all(self):
        """Ø¥ÙŠÙ‚Ø§Ù Ø¬Ù…ÙŠØ¹ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù†Ø´Ø± Ù…Ø¤Ù‚ØªØ§Ù‹"""
        self.paused = True
        logger.info("ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø¬Ù…ÙŠØ¹ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù†Ø´Ø± Ù…Ø¤Ù‚ØªØ§Ù‹")

    def resume_all(self):
        """Ø§Ø³ØªØ¦Ù†Ø§Ù Ø¬Ù…ÙŠØ¹ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù†Ø´Ø±"""
        self.paused = False
        logger.info("ØªÙ… Ø§Ø³ØªØ¦Ù†Ø§Ù Ø¬Ù…ÙŠØ¹ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù†Ø´Ø±")

    def get_running_ads(self):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†Ø§Øª Ù‚ÙŠØ¯ Ø§Ù„ØªØ´ØºÙŠÙ„"""
        return list(self.running_tasks.keys())
```

3.4 services/join_service.py

```python
# -*- coding: utf-8 -*-
import logging
import asyncio
from telethon import TelegramClient
from telethon.errors import FloodWaitError, InviteHashExpiredError, UserAlreadyParticipantError
from telethon.tl.functions.messages import ImportChatInviteRequest, CheckChatInviteRequest
from telethon.tl.types import ChatInviteAlready
import re

logger = logging.getLogger(__name__)

class JoinService:
    def __init__(self, db, api_id, api_hash):
        self.db = db
        self.api_id = api_id
        self.api_hash = api_hash
        self.join_tasks = {}

    def extract_invite_hash(self, invite_link):
        """Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù‡Ø§Ø´ Ù…Ù† Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ©"""
        patterns = [
            r't\.me/joinchat/([a-zA-Z0-9_-]+)',
            r't\.me/([a-zA-Z0-9_-]{22})',
            r'joinchat/([a-zA-Z0-9_-]+)'
        ]
        for pattern in patterns:
            match = re.search(pattern, invite_link)
            if match:
                return match.group(1)
        return None

    async def join_group(self, number_id, invite_link):
        """Ø§Ù†Ø¶Ù…Ø§Ù… Ø±Ù‚Ù… Ø¥Ù„Ù‰ Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¹Ø¨Ø± Ø±Ø§Ø¨Ø· Ø¯Ø¹ÙˆØ©"""
        number = self.db.get_number(number_id)
        if not number:
            return False, "Ø§Ù„Ø±Ù‚Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯"

        client = TelegramClient('temp_join', self.api_id, self.api_hash)
        try:
            client.session.load(number['session_string'])
            await client.connect()

            invite_hash = self.extract_invite_hash(invite_link)
            if not invite_hash:
                return False, "Ø±Ø§Ø¨Ø· Ø¯Ø¹ÙˆØ© ØºÙŠØ± ØµØ§Ù„Ø­"

            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø±Ø§Ø¨Ø·
            try:
                invites = await client(CheckChatInviteRequest(invite_hash))
                if isinstance(invites, ChatInviteAlready):
                    # Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„
                    return False, "Ø£Ù†Øª Ø¹Ø¶Ùˆ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©"
                # Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…
                updates = await client(ImportChatInviteRequest(invite_hash))
                chat = updates.chats[0]
                return True, f"ØªÙ… Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¥Ù„Ù‰ {chat.title}"
            except UserAlreadyParticipantError:
                return False, "Ø£Ù†Øª Ø¹Ø¶Ùˆ Ø¨Ø§Ù„ÙØ¹Ù„"
            except InviteHashExpiredError:
                return False, "Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© Ù…Ù†ØªÙ‡ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©"
            except FloodWaitError as e:
                return False, f"Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± {e.seconds} Ø«Ø§Ù†ÙŠØ©"
            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…: {e}")
                return False, str(e)
        finally:
            await client.disconnect()

    async def smart_join(self, user_id, numbers, invite_link, num_joins=1):
        """Ø§Ù†Ø¶Ù…Ø§Ù… Ø°ÙƒÙŠ Ø¨Ø¹Ø¯Ø© Ø£Ø±Ù‚Ø§Ù…"""
        joined_count = 0
        results = []
        for i in range(min(num_joins, len(numbers))):
            number = numbers[i]
            success, msg = await self.join_group(number['id'], invite_link)
            results.append((number['phone'], success, msg))
            if success:
                joined_count += 1
            await asyncio.sleep(random.randint(5, 15))  # ØªØ£Ø®ÙŠØ± Ø¨ÙŠÙ† Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
        return joined_count, results

    async def start_auto_join(self, user_id, numbers, invite_link, target_count):
        """Ø¨Ø¯Ø¡ Ø§Ù†Ø¶Ù…Ø§Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…Ø³ØªÙ…Ø±"""
        task_key = f"{user_id}_{invite_link}"
        if task_key in self.join_tasks:
            return False, "ÙŠÙˆØ¬Ø¯ Ø¨Ø§Ù„ÙØ¹Ù„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù†Ø¶Ù…Ø§Ù… Ù†Ø´Ø·Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø±Ø§Ø¨Ø·"

        async def join_loop():
            joined_so_far = 0
            while joined_so_far < target_count:
                available_numbers = [n for n in numbers if n['status'] == 'active']
                if not available_numbers:
                    break
                number = random.choice(available_numbers)
                success, msg = await self.join_group(number['id'], invite_link)
                if success:
                    joined_so_far += 1
                    logger.info(f"ØªÙ… Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¨ÙˆØ§Ø³Ø·Ø© {number['phone']} - {joined_so_far}/{target_count}")
                await asyncio.sleep(random.randint(30, 90))  # ØªØ£Ø®ÙŠØ± Ø¹Ø´ÙˆØ§Ø¦ÙŠ
            # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ù‡Ù…Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡
            del self.join_tasks[task_key]

        task = asyncio.create_task(join_loop())
        self.join_tasks[task_key] = task
        return True, "Ø¨Ø¯Ø£Øª Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ"

    def stop_auto_join(self, user_id, invite_link):
        """Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ"""
        task_key = f"{user_id}_{invite_link}"
        if task_key in self.join_tasks:
            self.join_tasks[task_key].cancel()
            del self.join_tasks[task_key]
            return True
        return False
```

3.5 services/fetch_service.py

```python
# -*- coding: utf-8 -*-
import logging
import re
import asyncio
from telethon import TelegramClient, events
from telethon.tl.types import Message

logger = logging.getLogger(__name__)

class FetchService:
    def __init__(self, db, api_id, api_hash):
        self.db = db
        self.api_id = api_id
        self.api_hash = api_hash
        self.fetching_tasks = {}
        self.link_patterns = {
            'telegram': r'(https?://)?(t\.me/|telegram\.me/)[a-zA-Z0-9_/+-]+',
            'whatsapp': r'(https?://)?(wa\.me/|chat\.whatsapp\.com/)[a-zA-Z0-9_/+-]+'
        }

    async def fetch_from_group(self, user_id, session_string, group_id):
        """Ø¬Ù„Ø¨ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ù…Ù† Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…Ø­Ø¯Ø¯Ø©"""
        client = TelegramClient('temp_fetch', self.api_id, self.api_hash)
        try:
            client.session.load(session_string)
            await client.connect()

            entity = await client.get_entity(int(group_id))
            messages = await client.get_messages(entity, limit=50)
            fetched = 0
            for msg in messages:
                if msg.text:
                    links = self.extract_links(msg.text)
                    for link, link_type in links:
                        self.db.add_fetched_link(user_id, group_id, link, link_type)
                        fetched += 1
            return True, f"ØªÙ… Ø¬Ù„Ø¨ {fetched} Ø±Ø§Ø¨Ø·"
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¬Ù„Ø¨: {e}")
            return False, str(e)
        finally:
            await client.disconnect()

    def extract_links(self, text):
        """Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ù…Ù† Ø§Ù„Ù†Øµ"""
        links = []
        for link_type, pattern in self.link_patterns.items():
            matches = re.findall(pattern, text)
            for match in matches:
                full_link = match[0] + match[1] if isinstance(match, tuple) else match
                links.append((full_link, link_type))
        return links

    async def start_auto_fetch(self, user_id, session_string, source_groups):
        """Ø¨Ø¯Ø¡ Ø¬Ù„Ø¨ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…Ø³ØªÙ…Ø± Ù…Ù† Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„Ù…ØµØ¯Ø±"""
        task_key = f"fetch_{user_id}"
        if task_key in self.fetching_tasks:
            return False, "Ø§Ù„Ø¬Ù„Ø¨ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…ÙØ¹Ù„ Ø¨Ø§Ù„ÙØ¹Ù„"

        async def fetch_loop():
            client = TelegramClient('auto_fetch', self.api_id, self.api_hash)
            try:
                client.session.load(session_string)
                await client.connect()

                @client.on(events.NewMessage(chats=source_groups))
                async def handler(event):
                    if event.message.text:
                        links = self.extract_links(event.message.text)
                        for link, link_type in links:
                            self.db.add_fetched_link(user_id, event.chat_id, link, link_type)
                            logger.info(f"ØªÙ… Ø¬Ù„Ø¨ Ø±Ø§Ø¨Ø· Ø¬Ø¯ÙŠØ¯: {link}")

                await client.run_until_disconnected()
            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¬Ù„Ø¨ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ: {e}")
            finally:
                await client.disconnect()
                if task_key in self.fetching_tasks:
                    del self.fetching_tasks[task_key]

        task = asyncio.create_task(fetch_loop())
        self.fetching_tasks[task_key] = task
        return True, "Ø¨Ø¯Ø£ Ø§Ù„Ø¬Ù„Ø¨ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ"

    def stop_auto_fetch(self, user_id):
        """Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¬Ù„Ø¨ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ"""
        task_key = f"fetch_{user_id}"
        if task_key in self.fetching_tasks:
            self.fetching_tasks[task_key].cancel()
            del self.fetching_tasks[task_key]
            return True
        return False
```

3.6 services/proxy_manager.py

```python
# -*- coding: utf-8 -*-
import logging
import random
import socks
from datetime import datetime

logger = logging.getLogger(__name__)

class ProxyManager:
    def __init__(self, db):
        self.db = db

    def get_proxy_dict(self, proxy):
        """ØªØ­ÙˆÙŠÙ„ Ø³Ø¬Ù„ Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠ Ø¥Ù„Ù‰ Ù‚Ø§Ù…ÙˆØ³ Ø¨ØªÙ†Ø³ÙŠÙ‚ telethon"""
        if not proxy:
            return None
        if proxy['proxy_type'] == 'socks5':
            return {
                'proxy_type': socks.SOCKS5,
                'addr': proxy['proxy_address'],
                'port': proxy['proxy_port'],
                'username': proxy['proxy_username'],
                'password': proxy['proxy_password']
            }
        # ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø£Ù†ÙˆØ§Ø¹ Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹
        return None

    def get_random_proxy(self):
        """Ø§Ø®ØªÙŠØ§Ø± Ø¨Ø±ÙˆÙƒØ³ÙŠ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
        proxies = self.db.get_proxies(active_only=True)
        if proxies:
            proxy = random.choice(proxies)
            self.db.increment_proxy_usage(proxy['id'])
            return self.get_proxy_dict(proxy)
        return None

    def add_proxy_from_string(self, proxy_string):
        """Ø¥Ø¶Ø§ÙØ© Ø¨Ø±ÙˆÙƒØ³ÙŠ Ù…Ù† Ù†Øµ Ø¨Ø§Ù„ØµÙŠØºØ©: socks5://user:pass@host:port Ø£Ùˆ host:port"""
        try:
            # ØµÙŠØºØ© Ø¨Ø³ÙŠØ·Ø©: host:port
            if '://' not in proxy_string and '@' not in proxy_string:
                parts = proxy_string.split(':')
                if len(parts) == 2:
                    host, port = parts
                    return self.db.add_proxy('socks5', host, int(port))
            # ØµÙŠØºØ© Ù…ØªÙ‚Ø¯Ù…Ø© (ÙŠÙ…ÙƒÙ† ØªØ·ÙˆÙŠØ±Ù‡Ø§ Ù„Ø§Ø­Ù‚Ø§Ù‹)
            return False
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø¨Ø±ÙˆÙƒØ³ÙŠ: {e}")
            return False

    def check_proxy_health(self, proxy_dict):
        """ÙØ­Øµ ØµØ­Ø© Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠ (ÙŠÙ…ÙƒÙ† ØªÙ†ÙÙŠØ°Ù‡ Ù„Ø§Ø­Ù‚Ø§Ù‹)"""
        # Ø³ÙŠØªÙ… ØªÙ†ÙÙŠØ°Ù‡ Ù„Ø§Ø­Ù‚Ø§Ù‹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… requests Ø£Ùˆ telethon
        pass
```

---

4. Ù…Ø¬Ù„Ø¯ handlers

4.1 handlers/__init__.py

```python
# Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù ÙŠØ¬Ø¹Ù„ Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø­Ø²Ù…Ø© Ø¨Ø§ÙŠØ«ÙˆÙ†
```

4.2 handlers/user_handlers.py

```python
# -*- coding: utf-8 -*-
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from datetime import datetime

logger = logging.getLogger(__name__)

class UserHandlers:
    def __init__(self, db, auth_service, publish_service, join_service, fetch_service, admin_ids):
        self.db = db
        self.auth_service = auth_service
        self.publish_service = publish_service
        self.join_service = join_service
        self.fetch_service = fetch_service
        self.admin_ids = admin_ids
        self.user_states = {}  # ØªØ®Ø²ÙŠÙ† Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¤Ù‚ØªØ§Ù‹

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø£Ù…Ø± /start"""
        user = update.effective_user
        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
        referred_by = None
        if context.args and context.args[0].startswith('ref_'):
            try:
                referred_by = int(context.args[0].split('_')[1])
            except:
                pass
        self.db.add_user(user.id, user.username, user.first_name, referred_by)

        # Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        keyboard = [
            [InlineKeyboardButton("ğŸ“± Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø±Ù‚Ø§Ù…", callback_data="manage_numbers")],
            [InlineKeyboardButton("ğŸ“¢ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†Ø§Øª", callback_data="manage_ads")],
            [InlineKeyboardButton("ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª", callback_data="manage_groups")],
            [InlineKeyboardButton("ğŸ”— Ø¬Ù„Ø¨ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·", callback_data="fetch_links")],
            [InlineKeyboardButton("ğŸ‘¤ Ø­Ø³Ø§Ø¨ÙŠ", callback_data="my_profile")]
        ]
        # Ø¥Ø¶Ø§ÙØ© Ø²Ø± Ø§Ù„Ø£Ø¯Ù…Ù† Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ø¯Ù…Ù†
        if user.id in self.admin_ids:
            keyboard.append([InlineKeyboardButton("âš™ï¸ Ù„ÙˆØ­Ø© Ø§Ù„Ø£Ø¯Ù…Ù†", callback_data="admin_panel")])

        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            f"Ù…Ø±Ø­Ø¨Ø§Ù‹ {user.first_name}!\n"
            "Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª Ù…Ø­Ø±Ù… Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„.\n"
            "Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£Ø¯Ù†Ø§Ù‡:",
            reply_markup=reply_markup
        )

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†ØµÙŠØ©"""
        user_id = update.effective_user.id
        text = update.message.text

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        if user_id in self.user_states:
            state = self.user_states[user_id]
            await self.handle_state(update, context, state)
            return

        # Ø±Ø¯ Ø§ÙØªØ±Ø§Ø¶ÙŠ
        await update.message.reply_text("Ø£Ø±Ø¬Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„Ù„ØªÙ†Ù‚Ù„.")

    async def handle_state(self, update, context, state):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø®ØªÙ„ÙØ© (Ø¥Ø¶Ø§ÙØ© Ø±Ù‚Ù…ØŒ Ø¥Ø¹Ù„Ø§Ù†ØŒ Ø§Ù„Ø®)"""
        user_id = update.effective_user.id
        text = update.message.text

        if state == 'waiting_phone':
            # ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø±Ù‚Ù… Ù…Ø¤Ù‚ØªØ§Ù‹ ÙˆØ·Ù„Ø¨ ÙƒÙˆØ¯
            context.user_data['phone'] = text
            success, msg = await self.auth_service.send_code(text)
            if success:
                self.user_states[user_id] = 'waiting_code'
                await update.message.reply_text("ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„Ù‡:")
            else:
                await update.message.reply_text(f"Ø®Ø·Ø£: {msg}")
                del self.user_states[user_id]

        elif state == 'waiting_code':
            phone = context.user_data.get('phone')
            code = text
            success, result = await self.auth_service.verify_code(phone, code)
            if success:
                # Ø­ÙØ¸ Ø§Ù„Ø±Ù‚Ù… ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                self.db.add_number(user_id, phone, result)
                await update.message.reply_text("âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø±Ù‚Ù… Ø¨Ù†Ø¬Ø§Ø­!")
                del self.user_states[user_id]
                del context.user_data['phone']
            elif result == "twofa_needed":
                self.user_states[user_id] = 'waiting_2fa'
                await update.message.reply_text("Ø§Ù„Ø±Ù‚Ù… Ù…ÙØ¹Ù„ Ø¨Ø®Ø·ÙˆØªÙŠÙ†. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±:")
            else:
                await update.message.reply_text(f"Ø®Ø·Ø£: {result}")

        elif state == 'waiting_2fa':
            phone = context.user_data.get('phone')
            twofa = text
            success, result = await self.auth_service.verify_twofa(phone, twofa)
            if success:
                self.db.add_number(user_id, phone, result, twofa=twofa)
                await update.message.reply_text("âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø±Ù‚Ù… Ø¨Ù†Ø¬Ø§Ø­!")
                del self.user_states[user_id]
                del context.user_data['phone']
            else:
                await update.message.reply_text(f"Ø®Ø·Ø£: {result}")

        elif state == 'waiting_ad_text':
            # Ø­ÙØ¸ Ù†Øµ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†
            context.user_data['ad_text'] = text
            keyboard = [
                [InlineKeyboardButton("Ø¹Ø§Ù…", callback_data="ad_type_public")],
                [InlineKeyboardButton("Ø®Ø§Øµ", callback_data="ad_type_special")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text("Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†:", reply_markup=reply_markup)
            # Ù„Ø§ Ù†Ø­Ø°Ù Ø§Ù„Ø­Ø§Ù„Ø©ØŒ Ø³Ù†ØªØ¹Ø§Ù…Ù„